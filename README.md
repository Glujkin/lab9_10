# Лабораторная работа № 9-10: Продвинутое ООП на Kotlin
## Описание
Лабораторная работа посвящена изучению продвинутых концепций объектно-ориентированного
программирования в Kotlin.
## Структура проекта
Проект содержит примеры реализации продвинутых механизмов ООП, а также пояснения к ключевым
концепциям.
## Как запустить проект
1. Клонируйте репозиторий:
```bash
git clone <URL_репозитория>
```
2. Откройте проект в IntelliJ IDEA.
3. Запустите любой пример через контекстное меню или напрямую из `main`.
## Автор
[Пономаренко, Шишкин]
## Лицензия
Проект создан в учебных целях.
## Геттеры и сеттеры
Геттеры и сеттеры — механизмы контроля доступа к свойствам класса.

Пример
```
class Hero(val name: String) {
var health: Int = 100
set(value) {
field = value.coerceIn(0,100)
}

var stamina: Int = 50
get() = field + 10
```
## Инкапсуляция
Сокрытие деталей реализации и предоставление контролируемого доступа.
```
Основные механизмы
. Модификаторы доступа (private, protected, internal, public)
. Кастомные геттеры/сеттеры
. Делегирование свойств
```

## Data-классы
Cпециальный тип классов для хранения данных.
```
Особенности:
. Автоматически генерируют toString(), equals(), hashCode(), copy()
. Должны иметь хотя бы один параметр в конструкторе
. Не могут быть унаследованы
```
Примеры:
```
data class OutpostResource(
val id: Int,
val name: String,
var amount: Int
){
override fun toString(): String {
return "Ваш ресурс: $id | Имя:$name | Количество:$amount"
}
}
```
## Абстрактные классы
базовые классы с частичной реализацией.
```
Особенности:

. Могут содержать абстрактные методы
. Не могут быть инстанцированы напрямую
. Служат основой для иерархии классов
```
Примеры
```
abstract class OutpustModule(
    val name: String,
    var level: Int = 1
) {
    fun upgrade(){
        level++
        println("$name улучшен до уровня $level")
    }
    abstract fun performAction(manager: ResouceManager)
}
```

## Интерфейсы
Это контракт поведения
```
Содержит:
. функции без реализации;
. функции с defeult-реализацией;
. свойства без хранения (только делкарации
```
Пример 

Определяем интерфейс видео плеера:
```
interface VideoPlayble{
    fun play() = println("Play video")
}
```
Определяем интерфейс аудио плеера:
```
interface VideoPlayble{
    fun play() = println("Play audio")
}
```
Далее создадим класс, который будет реализовывать оба интерфейса, и в нем переопределим метод для обоих интерфейсов
```
class MediaPlayer : VideoPlayble, AudioPlayable{
    override fun play(){
        println("Start playing")
        super<VideoPlayble>.play()
        super<AudioPlayable>.play()
    }
}
```
## Galaxy Outpost Mananer
Учебный проект на Kotlin, демонстрирующий основы объектно-ориентированного программирования и
архитектурные приёмы языка.
---
## Sealed-классы
__Sealed-классы__ используются для представления ограниченного набора состояний или результатов, которые
известны на этапе компиляции.

Они позволяют:

. гаранитровать обратку всех возможных вариантов;

. безопасно использовать конструкцию when без else;

. удобно описывать состояния, события и результаты действий.

## Пример: результат работы модуля
```
sealed-class ModuleResult {
    data class Success(val message: String) : ModuleResult()
    data class ResourceProduced(val resourceName: String, val amount: Int) : ModuleResult()
    data class NotEnoughResources(
        val resourceName: String,
        val required: Int,
        val available: Int
    ) : ModuleResult()
    data class Error(val reason: String) : ModuleResult()
}
```
## Объект в Kotlin

---
object — это специальная конструкция Kotlin, которая создаёт единственный экземпляр класса (Singleton).

Особенности:

. создаётся при первом обращении;

. существует в одном экземпляре;

. не имеет конструктора.

## Пример: глобальный логгер
```
object Logger {
private var counter = 0
    fun log(message: String) {
    counter++
    println("[$counter] $message")
  }
}
```
## Использование:
```
Logger.log("Инициализация системы")
Logger.log("Модуль запущен")
```
___object___ удобно использовать для:

. логгеров;

. конфигурации;

. состоянии без данных в sealed-класса;

. утилитарных классов.


## Делегирование свойств

Делегирование свойств позволяет передать логику хранения и обработки значения другому объекту.

В Kotlin это реализуется с помощью ключевого слова ___by.___

## Преимущества:

. уменьшение дублирования кода;

. централизованная логика проверки и обработки данных;

. более чистый и читаемый код.

## Пример: ограничение диапазона значения энергии
```
var energy: Int by Delegates.observable(100) { _, old, new->
    println("Энергия изменилась: $old → $new")
}
```
## Lazy (ленивая инициализация)
lazy позволяет инициализировать объект только при первом обращении к нему.

## Это полезно, если:

. объект создаётся не всегда;

. его создание ресурсоёмкое;

. нужно отложить инициализацию.

## Пример:
```
val resourceManager by lazy {
    ResourceManager()
}
```
Объект ResourceManager будет создан только при первом использовании.

## Observer-паттерн (наблюдатель)
Observer-паттерн позволяет объектам реагировать на изменения состояния другого объекта.

## В проекте Galaxy Outpost Manager наблюдатели могут:

. реагировать на изменение ресурсов;

. логировать события;

. уведомлять пользователя.

## Пример идеи:
```
. ResourceManager изменяет ресурсы;
. наблюдатель выводит сообщение в консоль при изменении.
. Сохранение состояния
```
Для сохранения состояния проекта используется сериализация в JSON.

## Это позволяет:

. сохранять данные между запусками программы;

. хранить состояние в человекочитаемом формате;

. легко перенести логику в Android-приложение.




